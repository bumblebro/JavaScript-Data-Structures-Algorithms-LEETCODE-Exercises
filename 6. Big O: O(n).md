# Understanding Big O Notation: O(n)

## Overview

We’ll begin with **O(n)**, not because it’s the most efficient or least efficient, but because it’s one of the easiest to understand. Here’s how it works:

## Example Function: `logItems`

We’ll use a simple function, `logItems`, that logs items to the console.

### Function Definition

```javascript
function logItems(n) {
    for (let i = 0; i < n; i++) {
        console.log(i);
    }
}

Explanation:
The function accepts a number n.
It runs a for loop n times.
On each iteration, it logs the value of i to the console.
Running the Function in Chrome Dev Tools
Call the function with the number 10:
javascript
Copy
Edit
logItems(10);
The output in the console will be the numbers 0 through 9.
Key Concept of O(n)
O(n) means the number of operations is proportional to the size of the input (n).
Example: If n is 10, the loop runs 10 times, logging 10 items.
Graph Representation of O(n)
The graph of O(n) is always a straight line.
X-axis: Represents n (input size).
Y-axis: Represents the number of operations.
As n increases, the number of operations increases linearly.
Key Takeaways
O(n): Describes algorithms where the number of operations grows linearly with the input size.
It’s simple and proportional, making it easy to visualize and understand.
Conclusion
O(n) is the first and most straightforward Big O notation.
We’ll use it as a baseline to compare with other Big O notations as we explore more examples.
Copy
Edit






